import{collection,addDoc,onSnapshot,doc,deleteDoc,updateDoc,serverTimestamp,query,orderBy,writeBatch,getDoc,setDoc,getDocs,arrayUnion,deleteField}from"https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";const{db:db}=window.firebaseInstances;async function uploadImageToImgBB(file){const apiKey=window.IMGBB_API_KEY;if(!apiKey)throw console.error("Chave da API do ImgBB não foi encontrada em window.IMGBB_API_KEY"),new Error("Chave da API do ImgBB não configurada.");const formData=new FormData;formData.append("image",file);try{const response=await fetch(`https://api.imgbb.com/1/upload?key=${apiKey}`,{method:"POST",body:formData});if(!response.ok){const errorData=await response.json();throw console.error("Erro da API do ImgBB:",errorData),new Error(`Falha no upload para o ImgBB: ${errorData.error.message}`)}const jsonResponse=await response.json();if(jsonResponse&&jsonResponse.data&&jsonResponse.data.url)return{url:jsonResponse.data.url};throw console.error("Resposta inesperada do ImgBB:",jsonResponse),new Error("Formato de resposta inesperado do ImgBB.")}catch(error){throw console.error("Erro crítico ao fazer upload da imagem para o ImgBB:",error),error}}const itemsCollectionRef=collection(db,"rpg-items"),usersCollectionRef=collection(db,"rpg-users");export async function saveUser(userName){const userDoc=doc(usersCollectionRef,userName.toLowerCase());await setDoc(userDoc,{name:userName,lastSeen:serverTimestamp()},{merge:!0})}export function listenToItems(callback){const q=query(itemsCollectionRef,orderBy("order","asc"));return onSnapshot(q,callback)}export async function addItem(itemData,file=null){const itemsCount=(await getDocs(itemsCollectionRef)).size,newItem={...itemData,createdAt:serverTimestamp(),order:itemsCount+1};if(file){const imageData=await uploadImageToImgBB(file);newItem.url=imageData.url}return(await addDoc(itemsCollectionRef,newItem)).id}export async function deleteItem(item){const itemDocRef=doc(db,"rpg-items",item.id);return deleteDoc(itemDocRef)}export async function deleteItems(itemIds){const batch=writeBatch(db);for(const id of itemIds){const docRef=doc(db,"rpg-items",id);batch.delete(docRef)}await batch.commit()}export async function updateItem(item,updatedData,newImageFile=null){if(newImageFile)try{const imageData=await uploadImageToImgBB(newImageFile);updatedData.url=imageData.url,updatedData.storagePath=deleteField()}catch(error){throw console.error("Erro ao fazer upload da nova imagem para o ImgBB:",error),new Error("Falha ao fazer upload da imagem")}const itemDocRef=doc(db,"rpg-items",item.id);return updateDoc(itemDocRef,updatedData)}export async function removeImageFromItem(item){if(!item||!item.id)throw new Error("É necessário um item válido para remover sua imagem.");const itemDocRef=doc(db,"rpg-items",item.id);await updateDoc(itemDocRef,{url:deleteField(),storagePath:deleteField()})}export async function updateItemsOrder(orderedIds){const batch=writeBatch(db);orderedIds.forEach(((id,index)=>{const docRef=doc(db,"rpg-items",id);batch.update(docRef,{order:index})})),await batch.commit()}export async function getItemsCount(){return(await getDocs(itemsCollectionRef)).size}export async function getSettings(){const docRef=doc(db,"config","mainSettings"),docSnap=await getDoc(docRef);return docSnap.exists()?docSnap.data():{siteTitle:"RPG Painel",recommendedTags:["NPC","Aliado"],filters:[{label:"PJs",value:"pj"}]}}export async function saveSettings(settingsData){const docRef=doc(db,"config","mainSettings");await setDoc(docRef,settingsData,{merge:!0})}export async function updateItemsVisibility(itemIds,isVisible){const batch=writeBatch(db);itemIds.forEach((id=>{const docRef=doc(db,"rpg-items",id);batch.update(docRef,{isVisibleToPlayers:isVisible})})),await batch.commit()}export async function addTagsToItems(itemIds,tagsToAdd){const batch=writeBatch(db);return itemIds.forEach((id=>{const docRef=doc(db,"rpg-items",id);batch.update(docRef,{tags:arrayUnion(...tagsToAdd)})})),batch.commit()}const chatCollectionRef=collection(db,"rpg-chat");export async function addChatMessage(text,type="user",senderName="Anônimo"){if(!text)return null;const newMsg={text:text,type:type,sender:senderName,createdAt:serverTimestamp()};return(await addDoc(chatCollectionRef,newMsg)).id}export function listenToChat(callback){const q=query(chatCollectionRef,orderBy("createdAt","asc"));return onSnapshot(q,callback)}